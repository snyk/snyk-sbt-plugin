import * as path from 'path';
import * as fs from 'fs';
import * as semver from 'semver';
import * as debugModule from 'debug';

// To enable debugging output, run the CLI as `DEBUG=snyk-sbt-plugin snyk ...`
const debug = debugModule('snyk-sbt-plugin');

import { sbtCoursierPluginName, sbtDependencyGraphPluginName, sbtDependencyGraphPluginNameNew } from './constants';
import * as subProcess from './sub-process';
import * as parser from './parse-sbt';
import * as types from './types';
import { isPluginInstalled } from './plugin-search';
import { getSbtVersion } from './version';

import * as tmp from 'tmp';
tmp.setGracefulCleanup();

interface InjectedScript {
  path: string;
  remove: () => void;
}

const packageFormatVersion = 'mvn:0.0.1';

export async function inspect(
  root,
  targetFile,
  options,
): Promise<types.PluginResult> {
  if (!options) {
    options = { dev: false };
  }

  const isCoursierPresent = await isPluginInstalled(
    root,
    targetFile,
    sbtCoursierPluginName,
  );
  const isSbtDependencyGraphPresent = await isPluginInstalled(
    root,
    targetFile,
    sbtDependencyGraphPluginName,
  ) || await isPluginInstalled(root,
    targetFile, sbtDependencyGraphPluginNameNew);
  Object.assign(options, { isCoursierPresent });
  // in order to apply the pluginInspect, coursier should *not* be present and sbt-dependency-graph should be present
  if (!isCoursierPresent && isSbtDependencyGraphPresent) {
    debug('applying plugin inspect');
    const res = await pluginInspect(root, targetFile, options);
    if (res) {
      res.package.packageFormatVersion = packageFormatVersion;

      return res;
    } else {
      debug(
        'coursier present = ' +
        isCoursierPresent +
        ', sbt-dependency-graph present = ' +
        isSbtDependencyGraphPresent,
      );
      debug('Falling back to legacy inspect');
      // tslint:disable-next-line:no-console
      console.warn(buildHintMessage(options));
    }
  } else {
    debug('falling back to legacy inspect');
  }
  const result = await legacyInspect(root, targetFile, options);
  const packageName = path.basename(root);
  const packageVersion = '0.0.0';
  const depTree = parser.parse(
    result.sbtOutput,
    packageName,
    packageVersion,
    result.coursier,
  );
  depTree.packageFormatVersion = packageFormatVersion;

  return {
    plugin: {
      name: 'bundled:sbt',
      runtime: 'unknown',
    },
    package: depTree,
  };
}

async function legacyInspect(root: string, targetFile: string, options: any) {
  const targetFilePath = path.dirname(path.resolve(root, targetFile));
  if (!fs.existsSync(targetFilePath)) {
    debug(
      `build.sbt not found at location: ${targetFilePath}. This may result in no dependencies`,
    );
  }
  let useCoursier = options.isCoursierPresent;

  const sbtArgs = buildArgs(options.args, useCoursier);

  try {
    return {
      sbtOutput: await subProcess.execute('sbt', sbtArgs, {
        cwd: targetFilePath,
      }),
      coursier: useCoursier,
    };
  } catch (error) {
    if (useCoursier) {
      // if we've tried coursier already, we'll fallback to dependency-graph
      // in case we've failed to parse the files correctly #paranoid
      useCoursier = false;
      const sbtArgsNoCoursier = buildArgs(options.args, useCoursier);
      return {
        sbtOutput: await subProcess.execute('sbt', sbtArgsNoCoursier, {
          cwd: targetFilePath,
        }),
        coursier: useCoursier,
      };
    } else {
      // otherwise cascade the reject

      error.message = error.message + buildHintMessage(options);

      throw error;
    }
  }
}

async function injectSbtScript(
  sbtPluginPath: string,
  targetFilePath: string,
): Promise<InjectedScript> {
  try {
    // We could be running from a bundled CLI generated by `pkg`.
    // The Node filesystem in that case is not real: https://github.com/zeit/pkg#snapshot-filesystem
    // Copying the injectable script into a temp file.
    const tmpSbtPlugin = tmp.fileSync({
      postfix: '-SnykSbtPlugin.scala',
      dir: path.resolve(targetFilePath, 'project/'),
    });
    fs.createReadStream(sbtPluginPath).pipe(
      fs.createWriteStream(tmpSbtPlugin.name),
    );
    return { path: tmpSbtPlugin.name, remove: tmpSbtPlugin.removeCallback };
  } catch (error) {
    error.message =
      error.message +
      '\n\n' +
      'Failed to create a temporary file to host Snyk script for SBT build analysis.';
    throw error;
  }
}

function generateSbtPluginPath(sbtVersion: string): string {
  let pluginName = 'SnykSbtPlugin-1.2x.scala';
  if (semver.lt(sbtVersion, '0.1.0')) {
    throw new Error('Snyk does not support sbt with version less than 0.1.0');
  }

  if (semver.gte(sbtVersion, '0.1.0') && semver.lt(sbtVersion, '1.1.0')) {
    pluginName = 'SnykSbtPlugin-0.1x.scala';
  }
  if (/index.[tj]s$/.test(__filename)) {
    return path.join(__dirname, `../scala/${pluginName}`);
  } else {
    throw new Error(`Cannot locate ${pluginName} script`);
  }
}

async function pluginInspect(
  root: string,
  targetFile: string,
  options: any,
): Promise<types.PluginResult | null> {
  let injectedScript: InjectedScript | undefined;
  try {
    const targetFilePath = path.dirname(path.resolve(root, targetFile));
    const sbtArgs = buildArgs(options.args, false, true);
    const sbtVersion = await getSbtVersion(root, targetFile);
    const sbtPluginPath = generateSbtPluginPath(sbtVersion);
    const packageName = path.basename(root);
    const packageVersion = '1.0.0';

    injectedScript = await injectSbtScript(sbtPluginPath, targetFilePath);
    debug('injectedScript.path: ' + injectedScript.path);
    const stdout = await subProcess.execute('sbt', sbtArgs, {
      cwd: targetFilePath,
    });
    return {
      plugin: {
        name: 'snyk:sbt',
        runtime: 'unknown',
        meta: {
          versionBuildInfo: {
            metaBuildVersion: {
              sbtVersion,
            },
          },
        },
      },
      package: parser.parseSbtPluginResults(
        stdout,
        packageName,
        packageVersion,
      ),
    };
  } catch (error) {
    debug(
      'Failed to produce dependency tree with custom snyk plugin due to error: ' +
      error.message,
    );
    return null;
  } finally {
    // in case of subProcess.execute failing, perform cleanup here, as putting it after `getInjectScriptPath` might
    // not be executed because of `sbt` failing
    if (injectedScript && injectedScript.remove) {
      try {
        injectedScript.remove();
        debug(`Removed the snyk sbt plugin at '${injectedScript.path}'`);
      } catch (error) {
        // NOTE(alexmu): we don't want to kill the whole run because we can still fall back to the legacy
        // method, but at least tell the user to clean up after the CLI :(.
        // tslint:disable-next-line:no-console
        console.warn(
          `Failed to remove the snyk sbt plugin file at '${injectedScript.path}'`,
        );
      }
    }
  }
}

function buildHintMessage(options) {
  const dgArgs = '`sbt ' + buildArgs(options.args, false).join(' ') + '`';
  const csArgs = '`sbt ' + buildArgs(options.args, true).join(' ') + '`';
  return (
    '\n\n' +
    'Please make sure that the `sbt-dependency-graph` plugin ' +
    '(https://github.com/jrudolph/sbt-dependency-graph) is installed ' +
    'globally or on the current project, and that ' +
    dgArgs +
    ' executes successfully on this project.\n\n' +
    'Alternatively you can use `sbt-coursier` for dependency resolution ' +
    '(https://get-coursier.io/docs/sbt-coursier), in which case ensure ' +
    'that the plugin is installed on the current project and that ' +
    csArgs +
    ' executes successfully on this project.\n\n' +
    'For this project we guessed that you are using ' +
    (options.isCoursierPresent ? 'sbt-coursier' : 'sbt-dependency-graph') +
    '.\n\n' +
    'If the problem persists, collect the output of ' +
    dgArgs +
    ' or ' +
    csArgs +
    ' and contact support@snyk.io\n'
  );
}

export function buildArgs(
  sbtArgs,
  isCoursierProject?: boolean,
  isOutputGraph?: boolean,
) {
  // force plain output so we don't have to parse colour codes
  let args = ['"-Dsbt.log.noformat=true"'];
  if (sbtArgs) {
    args = args.concat(sbtArgs);
  }

  if (isOutputGraph) {
    args.push('snykRenderTree'); // sbt-dependency-graph
  } else if (isCoursierProject) {
    args.push('coursierDependencyTree'); // coursier
  } else {
    args.push('dependencyTree'); // sbt native
  }

  return args;
}
